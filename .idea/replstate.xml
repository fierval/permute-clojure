<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1412485729720">{:repl-history {:ide [], :local [&quot;(nextGreater \&quot;3972\&quot;)&quot; &quot;(take 2 (nextGreater \&quot;2379\&quot;))&quot; &quot;(def v \&quot;2793\&quot;)&quot; &quot;(def pos2 pos1 (findStartingPos))&quot; &quot;(def pos2 pos1 (findStartingPos v))&quot; &quot;(def pos (findStartingPos v))&quot; &quot;(def v (String-&gt;Digits \&quot;2397\&quot;)) (def pos (findStartingPos v))&quot; &quot;pos&quot; &quot;(nextGreater \&quot;3297\&quot;)&quot; &quot;(def v (String-&gt;Digits \&quot;3297\&quot;))&quot; &quot;(findStartingPos v)&quot; &quot;(swapDigits v 3 1)&quot; &quot;(subvec [3 7 9 2] 0 2)&quot; &quot;(subvec [3 7 9 2] 2)&quot; &quot;(sort (subvec [3 7 9 2] 2))&quot; &quot;(into  (subvec [3 7 9 2] 0 2) (sort (subvec [3 7 9 2] 2)))&quot; &quot;(defn sort-remainder [v pos1]\n  (if (= (dec (count v)) pos1)\n    v\n    (into (subvec v 0 pos1) (sort (subvec v pos1)))\n    )\n  )\n&quot; &quot;(sort-remainder [3 7 9 2] 2)&quot; &quot;(nextGreater \&quot;2793\&quot;)&quot; &quot;(take 5 (nextGreater \&quot;2793\&quot;))&quot; &quot;v&quot; &quot;(dessoc v 1)&quot; &quot;(take 5 (nextGreater \&quot;3917410234\&quot;))&quot; &quot;(nextGreater \&quot;3917410234\&quot;)&quot; &quot;(take 3 (nextGreater \&quot;3972349103247901752\&quot;))&quot; &quot;(filter #(((complement nil?) (last %))) [[1 2] [3 nil]])&quot; &quot;((complement nil?) (last [3 nil]))&quot; &quot;(filter #(not-nil? (last %)) [[1 2] [3 nil]])&quot; &quot;(defn gm [acc]) (-&gt;&gt;\n  (filter #(not-nil? (last %)) acc))\n(reduce #(apply min (last %)))&quot; &quot;(defn gm [acc] (-&gt;&gt;\n              (filter #(not-nil? (last %)) acc)))\n(reduce #(apply min (last %)))&quot; &quot;(defn gm [acc] (-&gt;&gt;\n                 (filter #(not-nil? (last %)) acc)\n                 (reduce #(apply min (last %)))))&quot; &quot;(def acc [[1 2] [3 4] [5 nil]])&quot; &quot;(gm [[1 2] [3 4] [5 nil]])&quot; &quot;(gm\n  )&quot; &quot;(def a [[1 2] [3 4] [5 nil]])&quot; &quot;(gm a)&quot; &quot;(defn prarr [arr] arr)&quot; &quot;(prarr acc)&quot; &quot;(defn gm [acc] (-&gt;&gt;\n                 (filter #(not-nil? (last %)) acc)\n                 (reduce #(cons (apply min (last %1)) %2))))&quot; &quot;(gm acc)&quot; &quot;(reduce #(cons (apply min (last %2) %1)) acc)&quot; &quot;(reduce #(conj (apply min (last %2) %1)) acc)&quot; &quot;(reduce #(conj (apply min (last %2) %1)) [] acc)&quot; &quot;(reduce #(conj (apply min (last %1) %2)) [] acc)&quot; &quot;(def arr [[1 2] [3 4] [5 6]])&quot; &quot;(reduce #(conj (apply min (last %1) %2)) [] arr)&quot; &quot;(reduce #(conj (apply min (last %2) %1)) [] arr)&quot; &quot;(reduce #(conj (apply min (last %2)) %1) [] arr)&quot; &quot;(con (apply min (first arr) []))&quot; &quot;(conj (apply min (first arr) []))&quot; &quot;(conj (apply min (first arr)) [])&quot; &quot;(first arr)&quot; &quot;(apply min (first arr))&quot; &quot;(conj 1 [])&quot; &quot;(conj  [] 1)&quot; &quot;(conj [] (apply min (first arr)))&quot; &quot;(reduce #(conj %1 (apply min (last %2))) [] arr)&quot; &quot;(#(conj %1 (apply min (last %2))) [] [1 2])&quot; &quot;(filter #(not-nil? (last %)) acc)&quot; &quot;(def acc (filter #(not-nil? (last %)) acc))&quot; &quot;(reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) acc)&quot; &quot;(defn swapDigits [v pos1 pos2]\n  (assoc v pos2 (v pos1) pos1 (v pos2))\n  )\n\n(defn Digits-&gt;String [v]\n  (reduce #(str %1 (.toString %2)) v))\n\n(defn findFirstLessThan [v pos]\n  (let [cur pos]\n    (loop [cur cur]\n      (if (&lt; cur 0)\n        nil\n        (if (&lt; (v cur) (v pos)) cur (recur (dec cur))))))\n  )\n\n(def not-nil? (complement nil?))\n\n; Where should we start \&quot;promoting\&quot; from?\n; And who is the one we shold be replacing with?\n(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) acc)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (recur (dec cur) (cons [cur pos] acc))))))\n  )&quot; &quot;(findFirstLessThan [1 2 3] 2)&quot; &quot;(def acc [[2 1] [1 0]])&quot; &quot;(findStartingPos acc)&quot; &quot;(cons [1 2] [])&quot; &quot;(cons [1 2] [3 4])&quot; &quot;(conj [1 2] [])&quot; &quot;(concat [] [1 2])&quot; &quot;(conj [] [1 2])&quot; &quot;(cons [[1 2]] [3 4])&quot; &quot;(conj [[1 2]] [3 4])&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) acc)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (recur (dec cur) (conj acc [cur pos]))))))\n  )&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) acc)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (do\n            (println (cons acc [cur pos]))\n            (recur (dec cur) (conj acc [cur pos])))))))\n  )\n&quot; &quot;acc&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) acc)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (do\n            (println (conj acc [cur pos]))\n            (recur (dec cur) (conj acc [cur pos])))))))\n  )&quot; &quot;(def r [[2 1] [1 0] [0 nil]])&quot; &quot;(filter #(not-nil? (last %)) r)&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&lt; (last e) (last a)) [(first e) (last e)] a)) remNil)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (recur (dec cur) (conj acc [cur pos]))))))\n  )&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&gt; (last e) (last a)) [(first e) (last e)] a)) remNil)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (recur (dec cur) (conj acc [cur pos]))))))\n  )\n&quot; &quot;(findStartingPos [1 2 3])&quot; &quot;(findStartingPos [0 2 3 1])&quot; &quot;(filter #(not-nil? (last %)) [[1 nil]])&quot; &quot;(empty? (filter #(not-nil? (last %)) [[1 nil]]))&quot; &quot;(findFirstLessThan [3 2 1] 2)&quot; &quot;(defn findStartingPos [v]\n  (let [cur (dec (count v))]\n    (loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil])\n          (reduce (fn [a e] (if (&gt; (last e) (last a)) [(first e) (last e)] a)) remNil)\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (println acc)\n          (recur (dec cur) (conj acc [cur pos]))))))\n  )&quot; &quot;(findStartingPos [3 2 1])&quot; &quot;(filter #(not-nil? (last %)) (filter #(not-nil? (last %)) acc))&quot; &quot;(filter #(not-nil? (last %)) (filter #(not-nil? (last %)) [[2 nil] [1 nil]]))&quot; &quot;(defn swapDigits [v pos1 pos2]\n  (assoc v pos2 (v pos1) pos1 (v pos2))\n  )&quot; &quot;(defn findFirstLessThan [v pos]\n  (let [cur pos]\n    (loop [cur cur]\n      (if (&lt; cur 0)\n        nil\n        (if (&lt; (v cur) (v pos)) cur (recur (dec cur))))))\n  )&quot; &quot;(loop [cur cur\n           acc []]\n      (if (&lt; cur 0)\n        (let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil]\n            (reduce (fn [a e] (if (&gt; (last e) (last a)) [(first e) (last e)] a)) remNil))\n          )\n        (let [pos (findFirstLessThan v cur)]\n          (recur (dec cur) (conj acc [cur pos])))))&quot; &quot;(let [remNil (filter #(not-nil? (last %)) acc)]\n          (if (empty? remNil)\n            [nil nil]\n            (reduce (fn [a e] (if (&gt; (last e) (last a)) [(first e) (last e)] a)) remNil))\n          )&quot; &quot;(def not-nil? (complement nil?))&quot; &quot;(max 1 2)&quot; &quot;(con [5 2 3] 1)&quot; &quot;(conj [5 2 3] 1)&quot; &quot;(cons [5 2 3] 1)&quot; &quot;(cons '(5 2 3) 1)&quot; &quot;(cons 1 [5 2 3])&quot; &quot;(max -1 nil)&quot;], :remote []}}</component>
</project>

